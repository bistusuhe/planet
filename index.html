<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Galaxy - Dual Hand Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        
        /* UI Container */
        #ui-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Top Left: Status */
        .hud-panel {
            position: absolute;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 25px;
            border-radius: 30px;
            color: white;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: transform 0.2s;
        }

        #status-panel { top: 30px; left: 30px; }
        
        /* New Notification for Switching */
        #switch-notification {
            position: absolute;
            top: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 10px 30px;
            border-radius: 20px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #switch-notification.show { opacity: 1; }

        .indicator {
            width: 10px; height: 10px; border-radius: 50%;
            background: #555; transition: 0.3s;
        }
        .indicator.active { background: #00ff88; box-shadow: 0 0 10px #00ff88; }
        .indicator.switch { background: #00d5ff; box-shadow: 0 0 10px #00d5ff; }
        
        /* Top Right: Controls */
        #controls {
            top: 30px; right: 30px;
            pointer-events: auto;
            display: flex; gap: 10px;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 1px;
            transition: all 0.3s;
        }

        button:hover, button.active {
            background: white;
            color: black;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }

        #video-input {
            position: absolute; bottom: 10px; left: 10px;
            width: 160px; height: 120px;
            border-radius: 10px;
            opacity: 0.2;
            transform: scaleX(-1);
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; letter-spacing: 5px;
            animation: pulse 1.5s infinite;
            text-align: center;
        }
        #loading span { font-size: 14px; opacity: 0.7; display: block; margin-top: 10px; }

        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3"
            }
        }
    </script>
</head>
<body>

    <div id="loading">INITIALIZING<br><span>Allow Camera • 1 Hand = Form • 2 Hands = Switch</span></div>

    <div id="ui-container">
        <div id="status-panel" class="hud-panel">
            <div id="gesture-indicator" class="indicator"></div>
            <span id="gesture-text">Waiting for Hand...</span>
        </div>

        <div id="switch-notification" class="hud-panel">SWITCHING WORLD</div>

        <div id="controls" class="hud-panel" style="background:transparent; border:none; box-shadow:none;">
            <button onclick="SceneManager.switchModel('saturn')" class="active" id="btn-saturn">Saturn</button>
            <button onclick="SceneManager.switchModel('earth')" id="btn-earth">Earth</button>
            <button onclick="SceneManager.switchModel('moon')" id="btn-moon">Moon</button>
        </div>
    </div>

    <video id="video-input" autoplay playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- CONFIG ---
        const PARTICLE_COUNT = 50000;
        const PARTICLE_SIZE = 2.0;
        const RADIUS = 40;
        
        // Camera Config
        const CAM_Z_CLOSE = 120; // Scattered View
        const CAM_Z_FAR = 220;   // Formed View (Further back)

        // --- SHADERS ---
        const vertexShader = `
            uniform float uTime;
            uniform float uMorph;
            
            attribute vec3 targetPosition;
            attribute vec3 targetColor;
            attribute float sizeRandom;
            
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                vColor = targetColor;
                
                // Scatter Logic
                vec3 scatterPos = position;
                float timeOffset = uTime * 0.15;
                // Add gentle wave motion to scattered state
                scatterPos.x += sin(timeOffset + position.y * 0.05) * 10.0;
                scatterPos.y += cos(timeOffset + position.x * 0.05) * 10.0;
                scatterPos.z += sin(timeOffset + position.z * 0.05) * 10.0;

                // Expand scatter outwards significantly
                vec3 expandedScatter = normalize(position) * (length(position) + 120.0);

                // Morph: Mix between scatter and target
                vec3 finalPos = mix(expandedScatter, targetPosition, uMorph);

                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // Size attenuation
                float size = ${PARTICLE_SIZE.toFixed(1)} * sizeRandom;
                // Particles shrink slightly when packed to avoid total whiteout
                size = mix(size, size * 0.7, uMorph); 
                
                gl_PointSize = size * (400.0 / -mvPosition.z);
                
                vAlpha = mix(0.5, 1.0, uMorph);
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                float r = distance(gl_PointCoord, vec2(0.5));
                if (r > 0.5) discard;
                float glow = 1.0 - (r * 2.0);
                glow = pow(glow, 2.0); 
                gl_FragColor = vec4(vColor, vAlpha * glow);
            }
        `;

        // --- SCENE MANAGER ---
        const SceneManager = {
            scene: null, camera: null, renderer: null, composer: null,
            particles: null, geometry: null, material: null,
            shapesData: {},
            currentShapeIndex: 0,
            shapeKeys: ['saturn', 'earth', 'moon'],
            
            // State
            isFist: false,
            morphValue: 0,
            
            init: function() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x050505, 0.0015);

                this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = CAM_Z_CLOSE;
                this.camera.position.y = 10;

                this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                document.body.appendChild(this.renderer.domElement);

                const controls = new OrbitControls(this.camera, this.renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 0.8;
                controls.enableZoom = false; // We handle zoom manually

                // Bloom
                const renderScene = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.strength = 1.0;
                bloomPass.radius = 0.6;
                bloomPass.threshold = 0.1;

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderScene);
                this.composer.addPass(bloomPass);

                this.createParticles();
                this.generateShapes();
                this.createStarfield();
                this.switchModel('saturn');

                window.addEventListener('resize', () => this.onWindowResize(), false);
                this.animate();
            },

            createParticles: function() {
                this.geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(PARTICLE_COUNT * 3);
                const targets = new Float32Array(PARTICLE_COUNT * 3);
                const colors = new Float32Array(PARTICLE_COUNT * 3);
                const sizes = new Float32Array(PARTICLE_COUNT);

                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    // Random scatter sphere
                    const r = 200 + Math.random() * 150;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i*3+2] = r * Math.cos(phi);
                    sizes[i] = 0.5 + Math.random();
                }

                this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targets, 3));
                this.geometry.setAttribute('targetColor', new THREE.BufferAttribute(colors, 3));
                this.geometry.setAttribute('sizeRandom', new THREE.BufferAttribute(sizes, 1));

                this.material = new THREE.ShaderMaterial({
                    uniforms: { uTime: { value: 0 }, uMorph: { value: 0 } },
                    vertexShader: vertexShader, fragmentShader: fragmentShader,
                    transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
                });

                this.particles = new THREE.Points(this.geometry, this.material);
                this.scene.add(this.particles);
            },

            generateShapes: function() {
                const setP = (arr, i, x, y, z) => { arr[i*3]=x; arr[i*3+1]=y; arr[i*3+2]=z; };
                const setC = (arr, i, r, g, b) => { arr[i*3]=r; arr[i*3+1]=g; arr[i*3+2]=b; };

                // --- SATURN ---
                const sPos = new Float32Array(PARTICLE_COUNT*3), sCol = new Float32Array(PARTICLE_COUNT*3);
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    if(i < PARTICLE_COUNT*0.6) {
                        const r=RADIUS, theta=Math.random()*6.28, phi=Math.acos(2*Math.random()-1);
                        setP(sPos, i, r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                        const band = Math.abs(Math.cos(phi));
                        setC(sCol, i, 0.9, 0.8+band*0.1, 0.4);
                    } else {
                        const ang=Math.random()*6.28, dist=RADIUS*1.4+Math.random()*RADIUS*1.6;
                        setP(sPos, i, Math.cos(ang)*dist, (Math.random()-0.5)*1.5, Math.sin(ang)*dist);
                        const c = 0.6 + Math.sin((dist/RADIUS)*10)*0.2;
                        setC(sCol, i, c, c*0.9, 0.5);
                    }
                }
                this.shapesData.saturn = { pos: sPos, col: sCol };

                // --- EARTH ---
                const ePos = new Float32Array(PARTICLE_COUNT*3), eCol = new Float32Array(PARTICLE_COUNT*3);
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    const r=RADIUS, theta=Math.random()*6.28, phi=Math.acos(2*Math.random()-1);
                    const x=r*Math.sin(phi)*Math.cos(theta), y=r*Math.sin(phi)*Math.sin(theta), z=r*Math.cos(phi);
                    setP(ePos, i, x, y, z);
                    const n = Math.sin(theta*3)*Math.cos(phi*3) + Math.sin(theta*10+phi*5)*0.3;
                    if(n>0.2) setC(eCol, i, 0.1, 0.5+Math.random()*0.2, 0.1); // Land
                    else if(n>0.0) setC(eCol, i, 0.8, 0.8, 0.5); // Coast
                    else setC(eCol, i, 0.0, 0.2+Math.random()*0.2, 0.7); // Ocean
                    if(Math.random()>0.92) { // Cloud
                        const rc=r+1.2;
                        setP(ePos, i, rc*Math.sin(phi)*Math.cos(theta), rc*Math.sin(phi)*Math.sin(theta), rc*Math.cos(phi));
                        setC(eCol, i, 1.0, 1.0, 1.0);
                    }
                }
                this.shapesData.earth = { pos: ePos, col: eCol };

                // --- MOON ---
                const mPos = new Float32Array(PARTICLE_COUNT*3), mCol = new Float32Array(PARTICLE_COUNT*3);
                for(let i=0; i<PARTICLE_COUNT; i++) {
                    let r=RADIUS, theta=Math.random()*6.28, phi=Math.acos(2*Math.random()-1);
                    const n = Math.sin(theta*12)*Math.sin(phi*12) + Math.sin(theta*30)*0.2;
                    let c = 0.8;
                    if(n>0.7) { r-=1.5; c=0.4; } // Crater
                    else if(n<-0.5) { c=0.9; } // Highlands
                    setP(mPos, i, r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
                    setC(mCol, i, c, c, c+0.05);
                }
                this.shapesData.moon = { pos: mPos, col: mCol };
            },

            createStarfield: function() {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(2000*3);
                for(let i=0; i<2000*3; i++) pos[i] = (Math.random()-0.5)*800;
                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                const stars = new THREE.Points(geo, new THREE.PointsMaterial({color:0x888888, size:0.7}));
                this.scene.add(stars);
            },

            switchModel: function(name) {
                this.currentShapeIndex = this.shapeKeys.indexOf(name);
                const data = this.shapesData[name];
                
                // UI Update
                document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                document.getElementById(`btn-${name}`).classList.add('active');
                
                // Notification
                const notif = document.getElementById('switch-notification');
                notif.innerText = `MATERIALIZING: ${name}`;
                notif.classList.add('show');
                setTimeout(() => notif.classList.remove('show'), 2000);

                // Update Data
                this.geometry.attributes.targetPosition.array.set(data.pos);
                this.geometry.attributes.targetColor.array.set(data.col);
                this.geometry.attributes.targetPosition.needsUpdate = true;
                this.geometry.attributes.targetColor.needsUpdate = true;
            },

            cycleModel: function() {
                this.currentShapeIndex = (this.currentShapeIndex + 1) % this.shapeKeys.length;
                this.switchModel(this.shapeKeys[this.currentShapeIndex]);
            },

            animate: function() {
                requestAnimationFrame(() => this.animate());
                const dt = 0.016;
                this.material.uniforms.uTime.value += dt;

                // 1. Morph Logic
                const targetMorph = this.isFist ? 1.0 : 0.0;
                this.morphValue += (targetMorph - this.morphValue) * 0.05;
                this.material.uniforms.uMorph.value = this.morphValue;

                // 2. Dynamic Camera Distance Logic
                // If forming (morph > 0.5), pull back to FAR. If scattered, push in to CLOSE.
                const targetCamZ = this.isFist ? CAM_Z_FAR : CAM_Z_CLOSE;
                
                // Smooth camera transition (Lerp)
                this.camera.position.z += (targetCamZ - this.camera.position.z) * 0.04;

                this.particles.rotation.y += 0.001;
                this.composer.render();
            },

            setGestureState: function(state) {
                const elText = document.getElementById('gesture-text');
                const elInd = document.getElementById('gesture-indicator');

                if (state === 'switch') {
                    // Handled by cooldown logic mainly, but visual here
                    elText.innerText = "DUAL OPEN - CYCLING";
                    elInd.className = "indicator switch";
                    elText.style.color = "#00d5ff";
                    this.isFist = false; // Switch usually implies scatter during transition
                } else if (state === 'fist') {
                    this.isFist = true;
                    elText.innerText = "FIST - FORMING MATTER";
                    elInd.className = "indicator active";
                    elText.style.color = "#00ff88";
                } else {
                    this.isFist = false;
                    elText.innerText = "OPEN - SCATTERING";
                    elInd.className = "indicator";
                    elText.style.color = "white";
                }
            }
        };

        // --- VISION MANAGER ---
        const VisionManager = {
            handLandmarker: null,
            video: null,
            lastVideoTime: -1,
            lastSwitchTime: 0,

            init: async function() {
                try {
                    const vision = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                    );
                    this.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numHands: 2 // CHANGED: Detect 2 hands
                    });
                    this.video = document.getElementById("video-input");
                    navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                        this.video.srcObject = stream;
                        this.video.addEventListener("loadeddata", () => {
                            document.getElementById('loading').style.display = 'none';
                            this.predict();
                        });
                    });
                } catch (e) { console.error(e); }
            },

            predict: async function() {
                if (this.lastVideoTime !== this.video.currentTime) {
                    this.lastVideoTime = this.video.currentTime;
                    const results = this.handLandmarker.detectForVideo(this.video, performance.now());
                    this.processGestures(results);
                }
                requestAnimationFrame(() => this.predict());
            },

            processGestures: function(results) {
                const landmarks = results.landmarks;
                
                // Defaults
                let isFistDetected = false;
                let openHandCount = 0;

                if (landmarks && landmarks.length > 0) {
                    for (const hand of landmarks) {
                        if (this.isFist(hand)) {
                            isFistDetected = true;
                        } else {
                            openHandCount++;
                        }
                    }
                }

                // Logic: 
                // 1. Two hands open? -> Trigger Switch
                // 2. Any fist? -> Form Shape
                // 3. Else -> Scatter
                
                const now = Date.now();

                if (landmarks.length === 2 && openHandCount === 2) {
                    // Dual Open Gesture
                    if (now - this.lastSwitchTime > 1500) { // Cooldown 1.5s
                        SceneManager.cycleModel();
                        this.lastSwitchTime = now;
                    }
                    SceneManager.setGestureState('switch');
                } else if (isFistDetected) {
                    SceneManager.setGestureState('fist');
                } else {
                    SceneManager.setGestureState('open');
                }
            },

            isFist: function(landmarks) {
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20];
                let folded = 0;
                // Roughly estimate hand size for relative distance check
                const handSize = Math.sqrt(Math.pow(landmarks[0].x - landmarks[9].x, 2) + Math.pow(landmarks[0].y - landmarks[9].y, 2));
                
                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    const dist = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                    if (dist < handSize * 1.1) folded++;
                });
                return folded >= 3;
            }
        };

        window.SceneManager = SceneManager;
        SceneManager.init();
        VisionManager.init();
    </script>
</body>
</html>